#!/usr/bin/env python2
#
# Copyright 2015 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from functools import partial
from glob import glob
from jinja2 import Environment, FileSystemLoader
from json import load
from multiprocessing import Manager, Pool, cpu_count
from os import listdir, remove, makedirs
from os.path import basename, dirname, isdir, join, splitext
from re import match
from shutil import rmtree
from sys import stderr
"""Functions to dump a HTML representation of experimental data."""


def get_json(json, lst):
    if not basename(json) == "names":
        with open(json) as f: lst.append(load(f)) 


def load_jsons(file_list):
    man = Manager()
    lst = man.list()

    pool = Pool(cpu_count())
    curry = partial(get_json, lst=lst)
    pool.map(curry, file_list)

    return list(lst)


def transform_line(line):
    """Given a line from command output, returns a dict decorating that
    line with semantic information. See the doc for proc_log(), from
    which this method is invoked.
    """

    pat = "error: target not found: (?P<pkg>[-\.\w]+)"
    m = match(pat, line)
    if m:
        return {
              "text": line,
              "format": "error",
              "category": "missing_deps",
              "semantics": {
                      "bad_package": m.group("pkg")
                  }
                }

    # Default
    return {
        "text": line,
        "format": "none",
        "category": "none",
        "semantics": { }
    }


def proc_log(log):
    """Adds semantic information to the bodies of structs.

    Arguments:
        log: a list of log dicts as generated by utilities.log(). In
             particular, each dict is expected to have a body, which is
             a list of strings---each string corresponds to a line in
             the output of some command. i.e.
             [
                {
                    "head": "command_to_execute",
                    "body": [
                        "output line 1",
                        ...
                    ]
                },
                ...
             ]
    Returns:
        a new log, but with each line in the body of each log dict
        replaced with a dict that contains semantic information about
        the line. This method attempts to detect error-indicating lines
        in the bodies of log dicts.
             [
                {
                    "head": "command_to_execute",
                    "body": [
                        {
                            "text": "output line 1",
                            "format": "error",
                            "category": "dependency_fail",
                            "semantics": {
                                "bad_package": "foo"
                            }
                        }
                        ...
                    ]
                },
                ...
             ]
        Within each dict, the "text", "format", "category" and
        "semantics" keys are guaranteed to exist.  Other fields within
        "semantics" depend on what the "category" is.
    """
    ret = []
    for struct in log:
        # Modify a copy
        new_body = []
        for line in struct["body"]:
            new_body.append(transform_line(line))

        new_struct = dict(struct)
        new_struct["body"] = new_body
        ret.append(new_struct)

    return ret


def get_category_counts(build):
    category_counts = {}
    for struct in build["log"]:
        for line in struct["body"]:
            cat = line["category"]
            if cat not in category_counts:
                category_counts[cat] = 0
            category_counts[cat] += 1
    category_counts.pop("none", None)
    return category_counts


def write_single_package_pages(env, tc, vanilla_results):

    def seconds_to_hhmmss(seconds):
        hours, mins = divmod(seconds, 3600)
        mins, secs = divmod(mins, 60)
        return "%02d:%02d:%02d" % (hours, mins, secs)

    def get_vanilla_results_dict(results):
        res = {}
        for data in results:
            name = basename(data["package"])
            res[name] = data["return_code"]
        return res

    makedirs(join("html", tc))
    builds = []

    result_dir = sorted(listdir(join("results", tc)))[-1]
    result_dir = join("results", tc, result_dir, "pkgbuild_markers")

    results = glob(join(result_dir, "*"))
    stderr.write("Loading JSON files for toolchain '%s'\n" % (tc))
    results = load_jsons(results)

    if tc == "vanilla":
        tmp = get_vanilla_results_dict(results)
        for k, v in tmp.iteritems():
            vanilla_results[k] = v

    for data in results:
        package_name, _ = splitext(basename(data["package"]))

        data["time"] = seconds_to_hhmmss(data["time"])
        data["package_name"] = package_name

        data["log"] = proc_log(data["log"])

        data["category_counts"] = get_category_counts(data)

        templ = env.get_template("single_package.jinja.html")
        html = templ.render(data=data)

        name = basename(data["package"])
        path = join("html", tc, name, "index.html")

        data["build_name"] = name

        if vanilla_results[name] is None:
            data["built_on_vanilla"] = None
        elif vanilla_results[name] == 0:
            data["built_on_vanilla"] = True
        else:
            data["built_on_vanilla"] = False

        builds.append(data)
        try:
            makedirs(dirname(path))
        except OSError:
            pass
        with open(path, "w") as f:
            f.write(html.encode("utf-8"))
    return builds


def get_variations(builds):
    """Returns a list of result-list structures, filtered by criteria.
    """

    variations = []

    obj = {}
    obj["number"] = len(builds)
    obj["file_name"] = "index"
    obj["title"] = "All builds"
    obj["description"] = "built in total"
    variations.append((obj, builds))

    obj = {}
    new_builds = [b for b in builds if b["return_code"] == 0]
    obj["number"] = len(new_builds)
    obj["file_name"] = "success"
    obj["title"] = "Successful builds"
    obj["description"] = "built successfully"
    variations.append((obj, new_builds))

    obj = {}
    new_builds = [b for b in builds if b["return_code"] != 0]
    obj["number"] = len(new_builds)
    obj["file_name"] = "fail"
    obj["title"] = "Failed builds"
    obj["description"] = "failed to build successfully"
    variations.append((obj, new_builds))

    obj = {}
    new_builds = [b for b in builds if (b["return_code"] != 0
                                    and b["built_on_vanilla"])]
    obj["number"] = len(new_builds)
    obj["file_name"] = "tc_fail"
    obj["title"] = "Fails that built successfully on vanilla"
    obj["description"] = "failed but were successful on vanilla"
    variations.append((obj, new_builds))

    obj = {}
    new_builds = [b for b in builds
                    if "missing_deps" in  b["category_counts"]]
    obj["number"] = len(new_builds)
    obj["file_name"] = "dep_fail"
    obj["title"] = "Packages whose dependency failed to build"
    obj["description"] = "failed because their dependency didn't build"
    variations.append((obj, new_builds))

    obj = {}
    new_builds = [b for b in builds
                    if b["return_code"] and not b["category_counts"]]
    obj["number"] = len(new_builds)
    obj["file_name"] = "unknown_fail"
    obj["title"] = "Packages with unclassified failures"
    obj["description"] = "failed for some unknown reason"
    variations.append((obj, new_builds))

    return variations


def do_html(args):
    """Top-level function called when running tuscan.py html."""
    rmtree("html", ignore_errors=True)
    makedirs("html")

    env = Environment(loader=FileSystemLoader(["site_gen"]))

    vanilla_builds = []

    # We want to process the vanilla toolchain first if it exists, in
    # order to get the "build on vanilla" column on other toolchains
    toolchains = listdir("results")
    if isdir("results/vanilla"):
        toolchains.remove("vanilla")
        toolchains = ["vanilla"] + toolchains

    # This should get populated with build_name -> return_code on the
    # first run of the loop, and is used by write_single_package_pages
    # in subsequent iterations.
    vanilla_results = {}

    for tc in toolchains:
        results = write_single_package_pages(env, tc, vanilla_results)

        variations = get_variations(results)

        for desc, results in variations:
            results = {"toolchain": tc,
                      "packages": results,
                      "title": desc["title"],
                      "variations": [vs[0] for vs in variations],
                    }
            templ = env.get_template("toolchain.jinja.html")
            html = templ.render(data=results, toolchains=toolchains)
            path = join("html", tc, desc["file_name"] + ".html")
            with open(path, "w") as f:
                f.write(html.encode("utf-8"))
    stderr.write("\n")

    templ = env.get_template("top_level.jinja.html")
    html = templ.render(toolchains=toolchains)
    path = join("html", "index.html")
    with open(path, "w") as f:
        f.write(html.encode("utf-8"))
