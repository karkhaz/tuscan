#!/usr/bin/env python3
#
# Copyright 2015 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from utilities import OutputDirectory, get_argparser

from subprocess import run, PIPE
from sys import stderr
from json import dump


def circular_dependency_breakers():
    """A list of packages that must go in the bootstrap set.

    Due to circular makedependencies, we must bootstrap the build using
    additional binaries that are not in base or base-devel. This list
    was generated by repeatedly trying to build, and seeing what
    circular dependencies Ninja complained about. TODO: a better way
    would be to analyze all circular dependencies to figure out the
    minimal set of packages whose placement in the bootstrap set would
    break all circular dependency chains, instead of hardcoding it here.
    """
    return [
        "gcc-ada", "gcc-fortran", "gcc-objc", "python",
        "python2", "ghc", "cabal-install", "git", "mesa", "openmpi",
        "cmake", "gobject-introspection", "gtk3", "jdk7-openjdk",
        "jdk8-openjdk", "cups", "openldap", "libsasl", "apache-ant",
        "cairo", "qemu", "libcacard", "rubinius", "python2-pyqt5",
        "python-packaging", "python-setuptools",
        "python2-packaging", "python2-setuptools",
        "dmd", "libphobos", "libphobos-devel", "go", "fpc"
    ]


def package_list(group):
    """Get the packages in group 'group'."""
    ret = run(["pacman", "--query", "--groups", group],
              stdout=PIPE, universal_newlines=True)
    if ret.returncode:
        print("Pacman failed to query group %s" % group, file=stderr)
        exit(1)

    lst = []

    for line in ret.stdout.splitlines():
        pair = line.split(" ")
        if not len(pair) == 2:
            print("Bad output from pacman: %s" % line, file=stderr)
            exit(1)
        lst.append(pair[1])

    return lst


def format_as_python(package_list, name):
    ret = "%s = [" % name
    for pack in package_list:
        ret += "\"%s\", " % pack
    return ret + "]"


def main():
    parser = get_argparser()
    args = parser.parse_args()

    name_data = {}

    name_data["base"] = package_list("base")
    name_data["base_devel"] = package_list("base-devel")

    name_data["break_circular"] = circular_dependency_breakers()

    with OutputDirectory(args, __file__) as out_dir:
        with open(out_dir + "/names.json", "w") as names:
            dump(name_data, names)


if __name__ == "__main__":
    main()
